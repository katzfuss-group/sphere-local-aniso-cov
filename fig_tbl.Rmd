---
title: "fig_tbl"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

This markdown produces the figures and tables used in ``locally anisotropic covariance functions on the sphere'', starting from Figure 4.

```{r libs and source, eval = T, echo = F, include = F}
rm(list = ls())
source("func.R")
```

## Figure 4

```{r fig 4, eval = F}
fig4 <- function(){
    set.seed(1)
    alpha <- c(-0.7, 0.35, 0.44)  
    beta <- c(-1.2, 0.25, 0.44)  
    kappa <- 0
    range <- - 2 / log(0.05)
    nu <- 0.5
    nuggets = 0.05^2
    nsrt <- 50
    grd.obj <- grd_gen(nsrt)
    z.all <- z_gen(alpha, beta, grd.obj$grd.all, kappa, nu, range, nuggets)
    sphere_plot(z.all, rep(T, length(z.all)), grd.obj$lon, grd.obj$lat,
                draw.palette = T, fn = "example_alldata.pdf")
}
fig4()
```

## Figure 5

Setting the `range` parameter to `0.1`, in the isotropic case, we have on average $29$ responses that are correlated with each response by more than $5\%$.
```{r fig 5 6 7 tbl 1, eval = F}
sim_study <- function(type = c("iso", "axially", "nonsta"), plot.flag = F){
    set.seed(1)
    type = type[1]
    if(type == "iso"){
        alpha <- c(-0.5, 0.0, 0.0)  
        beta <- c(-0.5, 0.0, 0.0)  
        kappa <- 0
    }else if(type == "axially"){
        alpha <- c(-0.5, 0.0, 1.44)  
        beta <- c(-3.2, 0.0, 1.44)  
        kappa <- 0
    }else if(type == "nonsta"){
        alpha <- c(-0.5, -1.2, 1.44)  
        beta <- c(-3.2, -0.3, 1.44)  
        kappa <- 0.8
    }else{
        stop("Unsupported covariance type\n")
    }
    range <- 0.1
    nu <- 0.5
    nuggets = 0.05^2
    nsrt <- 50
    ns <- nsrt^2
    grd.obj <- grd_gen(nsrt)
    z.all <- z_gen(alpha, beta, grd.obj$grd.all, kappa, nu, range, nuggets)
    
    sim_func(ns = ns, grd.obj = grd.obj, z.all = z.all, nu = nu, 
             range = range, nuggets = nuggets, type = type)
}
sim_study("iso")
```

```{r plot sim data rslt, eval = F}
for(fn in list.files(pattern = "(rect|rand).*RData")){
    load(fn)
    sphere_plot(z.all = input$z.all, mask = input$mask, lon = input$lon, 
                lat = input$lat, draw.palette = T, 
                fn = input$fn, fig.width = 11.11, fig.height = 8.33, 
                zlim = c(-3, 3))
}
```

## Real Data Application

```{r real data, eval = F}
real_app <- function(test.flag = F, plot.flag = F)
{
    set.seed(1)
    data <- nc_open("tas_Amon_GFDL-CM3_rcp26_r1i1p1_200601-201012.nc")
    lon <- ncvar_get(data, "lon") / 180 * pi - pi
    lat <- ncvar_get(data, "lat") / 180 * pi
    time <- ncvar_get(data, "time")
    tas <- ncvar_get(data, "tas")
    idx.time <- 48
    z.all <- as.vector(tas[, , idx.time])
    if(test.flag){
        lon.idx <- round(seq(from = 1, to = length(lon), length.out = 72))
        lat.idx <- round(seq(from = 1, to = length(lat), length.out = 45))
        lon <- lon[lon.idx]
        lat <- lat[lat.idx]
        z.all <- as.vector(tas[lon.idx, lat.idx, idx.time])
    }
    grd.all <- as.matrix(expand.grid(lon, lat))
    grd.obj <- list(lon = lon, lat = lat, grd.all = grd.all)
    ns <- length(z.all)
    if(plot.flag)
        sphere_plot(z.all, rep(T, length(z.all)), lon, lat, fig.width = 13.44, 
                    fig.height = 8.73, draw.palette = T, fn = "Dec2019Temp.pdf")
    z.lat.mean <- colMeans(tas[, , idx.time])
    z.lat.sd <- apply(tas[, , idx.time], MARGIN = 2, FUN = sd)
    z.all <- (z.all - kronecker(z.lat.mean, rep(1, length(lon)))) /
        kronecker(z.lat.sd, rep(1, length(lon)))
    sim_func(ns = ns, grd.obj = grd.obj, z.all = z.all, nu = 2.5, 
             range = 0.1, nuggets = 0.05^2, type = "real")
}
real_app(test.flag = T)
```



